"""
Enhanced Test Generator
Generates test code based on the actual project architecture and interfaces.
"""

import json
import os
from pathlib import Path
from typing import Dict, Any, List, Optional
from jinja2 import Template

class EnhancedTestGenerator:
    """Generates test code based on real architecture information."""
    
    def __init__(self, interface_map_path: str = "interface_map.json"):
        self.interface_map = self._load_interface_map(interface_map_path)
        self.templates = self._load_templates()
        
    def _load_interface_map(self, path: str) -> Dict[str, Any]:
        """Load the interface map generated by the architecture mapper."""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            raise FileNotFoundError(f"Interface map file not found: {path}")
            
    def _load_templates(self) -> Dict[str, Template]:
        """Load Jinja2 templates for test generation."""
        templates = {}
        
        # Template for test class
        test_class_template = Template('''
import unittest
import {{ module_name }}
{% if imports %}from {{ imports[0].module }} import {{ imports[0].class_name }}{% endif %}

class Test{{ class_name }}(unittest.TestCase):
    """Test class for {{ class_name }}."""
    
    def setUp(self):
        """Set up test fixtures before each test method."""
        {% if constructor_params %}
        self.instance = {{ class_name }}({{ ', '.join(constructor_params) }})
        {% else %}
        self.instance = {{ class_name }}()
        {% endif %}
    
    {% for method in methods %}
    def test_{{ method }}(self):
        """Test the {{ method }} method."""
        # TODO: Implement test for {{ method }}
        pass
        
    {% endfor %}
    
    def tearDown(self):
        """Clean up after each test method."""
        pass
        
if __name__ == '__main__':
    unittest.main()
''')
        
        templates['test_class'] = test_class_template
        return templates
        
    def generate_test_for_class(self, class_name: str, output_dir: str = "tests/generated") -> str:
        """Generate a test file for a specific class."""
        if class_name not in self.interface_map["classes"]:
            raise ValueError(f"Class not found in interface map: {class_name}")
            
        class_info = self.interface_map["classes"][class_name]
        file_path = class_info["file_path"]
        module_name = file_path.replace(".py", "").replace("\\", ".")
        
        # Extract imports needed for this class
        imports = []
        if "modules" in self.interface_map:
            for module_path, module_info in self.interface_map["modules"].items():
                if class_name in module_info["classes"]:
                    for import_str in module_info["imports"]:
                        if "." in import_str:
                            parts = import_str.split(".")
                            imports.append({
                                "module": parts[0],
                                "class_name": parts[1]
                            })
        
        # Get constructor parameters by looking at the __init__ method
        constructor_params = []
        for func_name, func_info in self.interface_map.get("functions", {}).items():
            if func_name == f"{class_name}.__init__":
                constructor_params = func_info["parameters"]
                # Remove 'self' parameter
                if constructor_params and constructor_params[0] == "self":
                    constructor_params = constructor_params[1:]
                break
                
        # Get methods to test (excluding __init__)
        methods = [m for m in class_info["methods"] if m != "__init__"]
        
        # Render the template
        template = self.templates['test_class']
        rendered = template.render(
            class_name=class_name,
            module_name=module_name,
            file_path=file_path,
            imports=imports,
            constructor_params=constructor_params,
            methods=methods
        )
        
        # Create output directory if it doesn't exist
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Write the test file
        test_file_path = output_path / f"test_{class_name.lower()}.py"
        with open(test_file_path, 'w', encoding='utf-8') as f:
            f.write(rendered)
            
        print(f"Generated test for {class_name} at {test_file_path}")
        return str(test_file_path)
        
    def generate_all_tests(self, output_dir: str = "tests/generated") -> List[str]:
        """Generate test files for all classes in the project."""
        generated_files = []
        
        for class_name in self.interface_map["classes"].keys():
            try:
                file_path = self.generate_test_for_class(class_name, output_dir)
                generated_files.append(file_path)
            except Exception as e:
                print(f"Failed to generate test for {class_name}: {e}")
                
        print(f"Generated {len(generated_files)} test files")
        return generated_files
        
    def get_class_hierarchy(self) -> Dict[str, List[str]]:
        """Get the class hierarchy from the interface map."""
        hierarchy = {}
        
        for class_name, class_info in self.interface_map["classes"].items():
            base_classes = class_info["base_classes"]
            for base_class in base_classes:
                if base_class not in hierarchy:
                    hierarchy[base_class] = []
                hierarchy[base_class].append(class_name)
                
        return hierarchy
        
    def find_implementations_of_interface(self, interface_name: str) -> List[Dict[str, Any]]:
        """Find all classes that implement a specific interface."""
        implementations = []
        
        for class_name, class_info in self.interface_map["classes"].items():
            if interface_name in class_info["base_classes"]:
                implementations.append({
                    "class_name": class_name,
                    "file_path": class_info["file_path"],
                    "methods": class_info["methods"]
                })
                
        return implementations

def main():
    """Main function to run the enhanced test generator."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Enhanced Test Generator')
    parser.add_argument('--interface-map', default='interface_map.json', help='Path to interface map file')
    parser.add_argument('--output-dir', default='tests/generated', help='Directory to output generated tests')
    parser.add_argument('--interface', default='IndependenceTestBase', help='Interface to find implementations of')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    generator = EnhancedTestGenerator(interface_map_path=args.interface_map)
    
    # Generate tests for specific classes that inherit from the specified interface
    implementations = generator.find_implementations_of_interface(args.interface)
    if args.verbose:
        print(f"Found {len(implementations)} classes implementing {args.interface}:")
        for cls in implementations:
            print(f"  - {cls['class_name']} ({cls['file_path']})")
    
    # Generate tests for these classes
    for cls in implementations:
        generator.generate_test_for_class(cls["class_name"], output_dir=args.output_dir)
        
    # Option to generate all tests
    # generator.generate_all_tests()

if __name__ == "__main__":
    main()
